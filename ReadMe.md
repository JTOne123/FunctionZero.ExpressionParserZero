# *** DOCUMENTATION WORK IN PROGRESS ***

# FunctionZero.ExpressionParserZero
A fast and very flexible Infix to Postfix (Reverse Polish) parser, validator and evaluator.

## Overview

![Image of a basic flowchart for parsing and evaluating an expression](https://raw.githubusercontent.com/Keflon/FunctionZero.ExpressionParserZero/master/Images/BasicFlowchart.png "ExpressionParserZero usage flowchart")

`ExpressionParserZero` consists of an `ExpressionParser`, an `ExpressionEvaluator` and a `VariableSet`

### ExpressionParser

The `ExpressionParser` takes an *infix* expression and produces a *postfix* token list that can be evaluated using an `ExpressionEvaluator`  

```csharp
var ep = new ExpressionParser();
var postfix = ep.Parse("(6+2)*5");
Debug.WriteLine(TokenService.TokensAsString(postfix));
```
outputs the following *postfix* expression
```
[Operand:6][Operand:2][Operator:+][Operand:5][Operator:*]
```
### ExpressionEvaluator
The `ExpressionEvaluator` takes a *postfix* token list generated by the `ExpressionParser` and 'evaluates' it, producing a `Stack<Operand>`. 
Typically that stack will contain a single `Operand` that contains your result.
```csharp
var resultStack = evaluator.Evaluate(postfix, null);
Debug.WriteLine(TokenService.TokensAsString(resultStack));
IOperand result = resultStack.Pop();
Debug.WriteLine($"{result.Type}, {result.GetValue()}");
long answer = (long)result.GetValue();
Debug.WriteLine(answer);
```
outputs
```
[Operand:40]
Long, 40
40
```
### VariableSet
The `ExpressionEvaluator` evaluates the `postfix` expression against a `VariableSet`.


## Quickstart



### To evaluate (5+2)

```csharp
        public void AddTwoLongs()
        {
            ExpressionParser parser = new ExpressionParser();
            ExpressionEvaluator evaluator = new ExpressionEvaluator();

            var compiledExpression = parser.Parse("5+2");
            Debug.WriteLine("Compiled expression: "+TokenService.TokensAsString(compiledExpression));

            var evaluatedResult = evaluator.Evaluate(compiledExpression, null);
            Debug.WriteLine("Results Stack: "+TokenService.TokensAsString(evaluatedResult));

            long answer = (long)evaluatedResult.Pop().GetValue();
            Debug.WriteLine(answer);
        }
        // Output: [Operand:5][Operand:2][Operator:+]
        // Output: [Operand:7]
```



dzfgd
- Rich syntax checking
- Type-safe variable-sets with full cutomisation
- Operator overloads
- Function registration
- Pre-compiling expressions independently of variables

Supports the following operand types:
- Long
- NullableLong
- Double
- NullableDouble
- String
- Variable
- Bool
- NullableBool
- VSet
- Object    
- Null



